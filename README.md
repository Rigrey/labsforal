## Лабораторная работа 3

### Теория
- Переменная:
  ``` c++
  int a = 0;
  double b = 0.0;
  char c = 'H';
  ```
  Переменная - тривиальная единица информации в ЯП; именованная ячейка памяти. С переменными могут происходить операции:
  - Сложение: `a + b`
  - Вычитание: `a - b`
  - Умножение: `a * b`
  - Деление: `a / b`
  - Различные битовые (пока не рассматриваем)
- Типы:

  Все переменные в C++ имеют строгий тип. В любой момент времени тип переменной должен быть известен или предсказуем.
  Все элементарные типы переменных - это числа, но их трактовка в зависимости от ситуации может быть разной (например, вывод
  `int` в `std::cout` результирует в напечатанном числе, а `char` - в напечатанной букве). Соответственно, все вышеперечисленные
  операции справедливы ко всем тривиальным типам данных (`int` и его вариации, `double` и его вариации, `char` и его вариации).
  
  Интересной операцией с точки зрения типизации можно считать так называемое "приведение типов" - преобразование одного типа к
  другому: `size_t -> int`, `int -> double`, `double -> int` и так далее. В языке C++ это может происходить множеством различных
  способов, как явно (программист чётко обозначает в какой тип выражение будет преобразовано), так и неявно (типы преобразуются без
  явного упоминания этой операции программистом). Пример неявного преобразования (`(double)10.0 / (int)3 == (double)0.33...`,
  `(double)0.33 == (int)0`):
  ```c++
  int a = 10.0 / 3;
  ```
  Такого стоит избегать, и все преобразования должны быть явными, если это важно для логики программы. Явное преобразование стоит
  описывать как:
  ```c++
  int a = static_cast<int>(10.0 / 3);
  ```
  Так будет меньше проблем и вопросов, почему то что нулём математически не является, стало нулём.
  
  Иногда названия типов становится очень громоздким и нечитаемым, и тогда его лучше и удобнее понимать из контекста. Для
  этого можно вместо явной спецификации типа использовать неявную форму `auto`:
  ```c++
  auto var_name = 10.0 / 3;
  ```
  Этим не стоит увлекаться, потому что в простых случаях оно может усложнить читаемость кода, но разумно в случаях, когда
  спецификация типа выглядит как `std::unordered_multimap<std::string>::const_local_iterator`. Понимать конечно этот тип
  не нужно.
- Сложные типы:

  Самым простым и наиболее распространённым примером сложного типа является массив. Массив - это несколько расположенных подряд
  переменных, доступ к которым производится по "индексу" - их порядковому номеру в этой структуре. Нумерация переменных начинается
  с `0`. Массив представлен разными способами в стандартной библиотеке языка C++, но для простоты и не теряя общности, ограничимся
  типом `std::vector`.
  
  Взаимодействие с `std::vector` описывается следующим образом (представлен массив типов `int`):
  ```c++
  std::vector<int> my_vec = {0, 3, 5, -5, 7, 2, 4};
  size_t index = 3;
  std::cout << my_vec[index] << std::endl; // -5
  my_vec[3] = -6;
  std::cout << my_vec[3] << std::endl; // -6
  my_vec[index] += 2;
  std::cout << my_vec[3] << std::endl; // -4
  ```
  С семантической точки зрения `my_vec[index]` - это выражение, взаимодействие с которым аналогично результирующему типу (в данном
  случае это `int`, так как здесь массив типов `int`)
- Условия:

  Условия - это способ ввести вариативность в программу, проверяя справедливость выражения в условии.
  ```c++
  int a = 0;
  if (a % 2 == 0) {
      a++;
  }
  // a == 1
  a = 3;
  if (a % 2 == 0) {
      a++;
  }
  // a == 3 
  ```
  Выражение в условии должно быть типа `bool` или `int`. В первом случае, выражение считается справедливым, если его значение равно
  `true`, а во втором - если значение не равно нулю.
  Вообще говоря, условия можно понимать как циклы, число итераций которых равно не более 1
- Циклы:

  При возникновении массивов и другой вариативности во входных данных вашей подпрограммы почти всегда придётся прибегать к использованию
  циклов. Циклы позволяют провести одинаковый набор операций с вариативной частью, зависимой от какой-либо переменной по отношению к
  определённому набору данных. Примером такой безумной общности может стать обработка данных в массиве:
  ```c++
  std::vector<int> my_vec = {0, 3, 5, -5, 7, 2, 4};
  for (size_t i = 0; i < my_vec.size(); ++i) {
      std::cout << my_vec[i] << std::endl;
  }
  ```
  Этот пример показывает наиболее общее применение концепта циклов в программировании. При помощи цикла `for` - цикл, в котором объявляется
  вариативная часть - индекс массива (`size_t i = 0`), которая увеличивается каждый раз при очередном исполнении тела цикла (`++i`) и
  который исполняется до тех пор, пока условие справедливо (см. "Условия").
  Все поля, разделённые `;` в цикле `for` не являются обязательными. При пустом условии, оно считается справедливым.
  
  Такое применение цикла `for` излишне общно для большинства
  задач, поэтому в C++ есть различные его вариации. Наиболее интересен цикл "range-based for":
  ```c++
  for (int elem : my_vec) {
      std::cout << i << std::endl;
  }
  ```
  В нём индексирование происходит автоматически, и каждая его "итерация" - исполнение тела с определённым значением вариативной части,
  наделена вариативностью `elem` (или любое другое название переменной), которая в себе содержит элементы индексируемого (или более общно,
  итерируемого, но об этом потом) сложного типа. Для того чтобы можно было изменить значения сложного типа, необходимо использовать типы,
  оканчивающиеся амперсандом: `type_name&`. О том что это за чудо, расскажем позже.
  
  Также в C++ есть циклы `while`:
  ```c++
  while (statement) {
      // do something
  }
  ```
  который эквивалентен:
  ```c++
  for (; statement;)
  ```
  и `do-while`, который бесполезен и вреден для понимания кода.

### Инструкция
В директории `sources` заготовлены несколько файлов. В них есть шаблоны для заданий. Реализуйте функции в соответствии с заданием.

### Задание
1. Дан массив. Все его элементы:
    1. увеличить в 2 раза;
    2. уменьшить на число `a`;
    3. разделить на первый элемент.

2. Определить:
    1. сумму всех элементов массива;
    2. сумму квадратов всех элементов массива;
    3. сумму шести первых элементов массива;
    4. сумму  элементов  массива  с `k1`-го по `k2`й;
    5. среднее арифметическое всех элементов массива;
    6. среднее арифметическое элементов массива с `s1`-го по `s2`-й.

3. Дан  одномерный массив  из  20 элементов.  Переставить  первые  три  и  последние три элемента, сохранив порядок их следования.

4. Удалить из массива:
    1. первый отрицательный элемент (если отрицательные элементы в массиве есть);
    2. удалить  последний  четный  элемент  (если  четные  элементы  в  массиве есть).

5. Дано название города. Определить, четно или нет количество символов в нем.
6. Даны две фамилии. Верните `true`, если первая длинее.
7. Даны названия трех городов. Запишите в `the_longest` самое длинное, а самое короткое название в `the_shortest`.

8. Дано слово. Получить его часть, образованную идущими подряд буквами, начиная с `m`-й и кончая `n`-й.
9. Дано  слово.  Добавить  к  нему  в  начале  и  конце  столько  звездочек,  сколько букв в этом слове.
10. Дано предложение. Определить долю (в %) букв `'a'` в нем.
11. Дано предложение `"Can you can a can as a canner can can a can?"`. Заменить все слова `can` на слово `new_word`.


## Полезные ссылки и литература
* https://github.com/bmstu-iu8-cpp/cpp-beginner-2017/blob/master/lab3/lab3_1.cpp
